* 数据类型
一般用 lu_byte tt_ 来表示
#+BEGIN_SRC C
/*
** tags for Tagged Values have the following use of bits:
** bits 0-3: actual tag (a LUA_T* value)
** bits 4-5: variant bits
** bit 6: whether value is collectable
*/
#+END_SRC

** 基本类型
用低4位标识, 代码里面用nov或者type表示
#+BEGIN_SRC C
#define novariant(x)	((x) & 0x0F)
#define ttnov(o)	(novariant(rttype(o)))
#+END_SRC

定义如下
#+BEGIN_SRC C
#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8
#+END_SRC

** 扩展类型
用低6位标识, 代码里面用raw或者tag表示
#+BEGIN_SRC C
#define ttyperaw(t)	((t) & 0x3F)
#define ttype(o)	ttyperaw(rttype(o))
#+END_SRC

定义如下
#+BEGIN_SRC C
/* Variant tags for functions */
#define LUA_TLCL	(LUA_TFUNCTION | (0 << 4))  /* Lua closure */
#define LUA_TLCF	(LUA_TFUNCTION | (1 << 4))  /* light C function */
#define LUA_TCCL	(LUA_TFUNCTION | (2 << 4))  /* C closure */


/* Variant tags for strings */
#define LUA_TSHRSTR	(LUA_TSTRING | (0 << 4))  /* short strings */
#define LUA_TLNGSTR	(LUA_TSTRING | (1 << 4))  /* long strings */


/* Variant tags for numbers */
#define LUA_TNUMFLT	(LUA_TNUMBER | (0 << 4))  /* float numbers */
#define LUA_TNUMINT	(LUA_TNUMBER | (1 << 4))  /* integer numbers */
#+END_SRC

** 垃圾收集标志
#+BEGIN_SRC C
/* Bit mark for collectable types */
#define BIT_ISCOLLECTABLE	(1 << 6)
#+END_SRC

* hash表
也就是table，通过Node记录冲突的节点. 如果是数组，ID小于sizearray的时候，直接去array里面找。否则通过hash函数去node里面找。
hash函数就是普通的取模操作, 注意lsizenode不直接是node的数量，要1<<lsizenode才是
#+BEGIN_SRC C
typedef struct Table {
  CommonHeader;
  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */
  lu_byte lsizenode;  /* log2 of size of 'node' array */
  unsigned int sizearray;  /* size of 'array' array */
  TValue *array;  /* array part */
  Node *node;
  Node *lastfree;  /* any free position is before this position */
  struct Table *metatable;
  GCObject *gclist;
} Table;
#+END_SRC

** Node
Node里面有key和value，next表示的是table中下一个节点的相对位置
#+BEGIN_SRC C
/*
** Nodes for Hash tables. A pack of two TValue's (key-value pairs)
** plus a 'next' field to link colliding entries. The distribuition
** of the key's fields ('key_tt' and 'key_val') not forming a proper
** 'TValue' allows for a smaller size for 'Node' both in 4-byte
** and 8-byte alignments.
*/
typedef union Node {
  struct NodeKey {
    TValuefields;  /* fields for value */
    lu_byte key_tt;  /* key type */
    int next;  /* for chaining */
    Value key_val;  /* key value */
  } u;
  TValue i_val;  /* direct access to node's value as a proper 'TValue' */
} Node;
#+END_SRC

* 垃圾收集
#+BEGIN_SRC C
/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/
#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked


/*
** Common type has only the common header
*/
struct GCObject {
  CommonHeader;
};
#+END_SRC



* TString
#+BEGIN_SRC C
/*
** Header for string value; string bytes follow the end of this structure
** (aligned according to 'UTString'; see next).
*/
typedef struct TString {
  CommonHeader;
  lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
  lu_byte shrlen;  /* length for short strings */
  unsigned int hash;
  union {
    size_t lnglen;  /* length for long strings */
    struct TString *hnext;  /* linked list for hash table */
  } u;
} TString;
#+END_SRC

* TValue
#+BEGIN_SRC C
typedef union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Integer i;   /* integer numbers */
  lua_Number n;    /* float numbers */
} Value;

#define TValuefields	Value value_; lu_byte tt_

typedef struct TValue {
  TValuefields;
} TValue;
#+END_SRC
