* PxQuat::rotateInv
#+begin_src
PX_CUDA_CALLABLE PX_FORCE_INLINE const PxVec3 rotateInv(const PxVec3& v) const
{
	const float vx = 2.0f * v.x;
	const float vy = 2.0f * v.y;
	const float vz = 2.0f * v.z;
	const float w2 = w * w - 0.5f;	// 1/2 cos(x)
	const float dot2 = (x * vx + y * vy + z * vz);	// 旋转轴和坐标得点乘 * 2
	return PxVec3((vx * w2 - (y * vz - z * vy) * w + x * dot2), (vy * w2 - (z * vx - x * vz) * w + y * dot2),
		      (vz * w2 - (x * vy - y * vx) * w + z * dot2));
//   v * cos(*)
// - (x,y,z) CROSS v * cos(*)
// + (x,y,z) * 2 * ((x, y, z) DOT v)
}  
#+end_src


* g_PCMContactMethodTable
定义了各类型得碰撞检测函数
#+begin_src C++
const PxcContactMethod conMethod = g_PCMContactMethodTable[type0][type1];
conMethod(shape0->geometry, shape1->geometry, *tm0, *tm1, context.mNarrowPhaseParams, cache, context.mContactBuffer, &context.mRenderOutput);  
#+end_src

* PxcPCMContactSphereSphere 球球
** 碰撞判断
从transform0取位置
从shapeSphere0.radius取半径
从params.mContactDistance取允许得距离
用距离得平方 与 半径加上允许得距离得平方比较，判断是否碰撞

** 碰撞点
对距离取sqrt
对距离向量归一化，得到碰撞法线
对一个球做法线乘以半径加上位置, 得到碰撞点
距离减半径，得到碰撞深度

碰撞法线 保存在 contact.normal
碰撞点   保存在 contact.point
碰撞深度 保存在 contact.separation
碰撞面   保存在 contact.internalFaceIndex1, 球体是PXC_CONTACT_NO_FACE_INDEX

* PxcPCMContactSpherePlane 球面
** 碰撞判断
从transform1.q取面得旋转
把球得坐标转换到面得坐标系下 transf1.transformInv(p0)
把球得X轴坐标减去半径，和允许得距离比较 (为啥是X? 要看上一步坐标系转换得实现)
看了下，原来，四元数PxQuat表示旋转的时候，x,y,z,w是归一化的，并且x,y,z表示旋转轴,w 表示cos(*/2), 0方向是(1,0,0)
不知道为啥要这样表示，要看后面的计算需要，难道这样会比较方便？
** 碰撞点


* PxcPCMContactSphereCapsule 球胶囊体

* PxcPCMContactSphereBox

* PxcPCMContactSphereConvex

* PxcPCMContactSphereMesh

* PxcPCMContactPlaneCapsule 面胶囊体

* PxcPCMContactPlaneBox

* PxcPCMContactPlaneConvex

* PxcPCMContactCapsuleCapsule 胶囊体胶囊体

* PxcPCMContactCapsuleBox

* PxcPCMContactCapsuleConvex

* PxcPCMContactCapsuleMesh

* PxcPCMContactBoxBox 盒子盒子

* PxcPCMContactBoxConvex

* PxcPCMContactBoxMesh

* PxcPCMContactConvexConvex 多面体多面体

* PxcPCMContactConvexMesh


