* g_PCMContactMethodTable
定义了各类型得碰撞检测函数
#+begin_src C++
const PxcContactMethod conMethod = g_PCMContactMethodTable[type0][type1];
conMethod(shape0->geometry, shape1->geometry, *tm0, *tm1, context.mNarrowPhaseParams, cache, context.mContactBuffer, &context.mRenderOutput);  
#+end_src

* PxcPCMContactSphereSphere 球球
** 碰撞判断
从transform0取位置
从shapeSphere0.radius取半径
从params.mContactDistance取允许得距离
用距离得平方 与 半径加上允许得距离得平方比较，判断是否碰撞

** 碰撞点
对距离取sqrt
对距离向量归一化，得到碰撞法线
对一个球做法线乘以半径加上位置, 得到碰撞点
距离减半径，得到碰撞深度

碰撞法线 保存在 contact.normal
碰撞点   保存在 contact.point
碰撞深度 保存在 contact.separation
碰撞面   保存在 contact.internalFaceIndex1, 球体是PXC_CONTACT_NO_FACE_INDEX

* PxcPCMContactSpherePlane 球面
** 碰撞判断
从transform1.q取面得旋转
把球得坐标转换到面得坐标系下 transf1.transformInv(p0)
把球得X轴坐标减去半径，和允许得距离比较 (为啥是X? 要看上一步坐标系转换得实现)
看了下，原来，四元数PxQuat表示旋转的时候，x,y,z,w是归一化的，并且x,y,z表示旋转轴,w 表示cos(*/2), 0方向是(1,0,0)
不知道为啥要这样表示，要看后面的计算需要，难道这样会比较方便？
** 碰撞点


* PxcPCMContactSphereCapsule 球胶囊体

* PxcPCMContactSphereBox

* PxcPCMContactSphereConvex

* PxcPCMContactSphereMesh

* PxcPCMContactPlaneCapsule 面胶囊体

* PxcPCMContactPlaneBox

* PxcPCMContactPlaneConvex

* PxcPCMContactCapsuleCapsule 胶囊体胶囊体

* PxcPCMContactCapsuleBox

* PxcPCMContactCapsuleConvex

* PxcPCMContactCapsuleMesh

* PxcPCMContactBoxBox 盒子盒子

* PxcPCMContactBoxConvex

* PxcPCMContactBoxMesh

* PxcPCMContactConvexConvex 多面体多面体

* PxcPCMContactConvexMesh


