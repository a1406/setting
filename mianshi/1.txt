1: valgrind sanitize
valgrind慢，不能检测栈溢出，包括全局变量的溢出。而sanitize不能检测变量的未初始化的读取
https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools

2: 日志
分开发用的调试日志和经分日志，经分日志发送至远程或别的线程。调试日志同步写。

3：protobuf
a: C++版本
编译慢，未优化版本速度慢。接口使用方便，大的结构体开启arena，见 
https://www.cnblogs.com/sun-shy/p/9775346.html

b: C版本
编译快，未优化和优化版本速度都和C++优化后的差不多速度。但是接口使用不方便，主要是打包的时候不方便。

c: lua版本
数据包转发的时候，使用userdata避免拷贝。

4: epoll可仿照redis开启无锁队列多线程读写

5: 共享内存恢复模式

6：共享内存无锁队列的两种方式

7：及时落地的思路，修改数据暂存redis，完整保存后删除

8：难点：
同步，寻路（碰撞）

9: lua
可以提高稳定性，服务器不容易崩溃。但是也带来问题
a:  业务容易中断，产生业务上的漏洞
先删后加
xpcall之类的调用，尽量让中断的范围小一些

b: lua部分的内存不能使用共享内存
思路1： 修改lua虚拟机并添加lua函数，让指定内存在共享内存上保存。
思路2： 修改lua虚拟机，让lua所有内存都在共享内存上保存

10: AI
脚本： 最灵活，对策划要求较高
行为树：  对策划要求相对较低，但是功能不是那么强大，尤其是基于事件(状态机)的回调不好做。另外程序看起来不习惯，可以通过工具生成伪代码
程序实现：  对策划几乎无要求，但是修改不方便
思考： 组合实现

11: 架构设计
分区分服，全区全服

12: 工具和自动化
脚本和行为树
部署脚本

13: gate
epoll libevent redis，多线程，websocket，扩容

14：game
视野管理，同步，AI，寻路，碰撞，扩容

15：DB
分库分表，扩容，无状态

16：word
扩容，无状态

17：代码质量和性能优化
valgrind，gprof
减少拷贝，建立索引，内存池，对象池

18: 自动化测试
a: 单元测试用例, 比如对单个函数的输入输出，或者AI行为的输入输出等
b: 压力测试，两种方式，一个是手写机器人行为，另外一个是录包

19: GM命令打印信息

20：gate服务器dump数据包


